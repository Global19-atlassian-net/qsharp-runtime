; Copyright (c) Microsoft Corporation. All rights reserved.
; Licensed under the MIT License.

;=======================================================================================================================
; QIR types
;
%Array = type opaque
%Callable = type opaque
%Qubit = type opaque
%Range = type { i64, i64, i64 }
%Result = type opaque
%String = type opaque
%Tuple = type opaque
%Pauli = type {i2}

;=======================================================================================================================
; Native types
; NB: there is no overloading at IR level, so a call/invoke will be made even
; if the definition of the function mismatches the declaration of the arguments.
; It means we could declare here the bridge's C-functions using QIR types
; and avoid bitcasts. However, it seems prudent to be more explicit about
; what's going on and declare the true signatures, as generated by Clang.
;
%class.QUBIT = type opaque
%class.RESULT = type opaque
%"struct.QirArray" = type opaque
%"struct.QirCallable" = type opaque
%"struct.QirRange" = type { i64, i64, i64 }
%"struct.QirString" = type opaque
; %Tuple* is mapped to i8*

;=======================================================================================================================
; declarations of the native APIs the bridge redirects to
;=======================================================================================================================

;------------------------------------------------------------------------------
; classical
;
declare i8* @quantum__rt__heap_alloc(i32)
declare void @quantum__rt__heap_free(i8*)
declare void @quantum__rt__fail(%"struct.QirString"*)

;------------------------------------------------------------------------------
; methods that delegate to the simulators
;
declare %class.QUBIT* @quantum__rt__qubit_allocate()
declare void @quantum__rt__qubit_release(%class.QUBIT*)
declare i1 @quantum__rt__result_equal(%class.RESULT*, %class.RESULT*)
declare void @quantum__rt__result_reference(%class.RESULT*)
declare void @quantum__rt__result_unreference(%class.RESULT*)

;------------------------------------------------------------------------------
; arrays
;
declare %"struct.QirArray"* @quantum__rt__qubit_allocate_array(i64)
declare void @quantum__rt__qubit_release_array(%"struct.QirArray"*)
declare %"struct.QirArray"* @quantum__rt__array_copy(%"struct.QirArray"*, i2 %force)
declare %"struct.QirArray"* @quantum__rt__array_concatenate(%"struct.QirArray"*, %"struct.QirArray"*)
declare %"struct.QirArray"* @quantum__rt__array_create_1d(i32, i64)
declare %"struct.QirArray"* @quantum__rt__array_create_nonvariadic(i32, i32, i8*)
declare i32 @quantum__rt__array_get_dim(%"struct.QirArray"*)
declare i8* @quantum__rt__array_get_element_ptr_1d(%"struct.QirArray"*, i64)
declare i8* @quantum__rt__array_get_element_ptr_nonvariadic(%Array*, i8*)
declare i64 @quantum__rt__array_get_length(%"struct.QirArray"*, i32)
declare %"struct.QirArray"* @quantum__rt__array_project(%"struct.QirArray"*, i32, i64)
declare void @quantum__rt__array_reference(%"struct.QirArray"*)
declare %"struct.QirArray"* @quantum__rt__array_slice(%"struct.QirArray"*, i32, %"struct.QirRange"* dereferenceable(24))
declare void @quantum__rt__array_unreference(%"struct.QirArray"*)
declare void @quantum__rt__array_add_access(%"struct.QirArray"*)
declare void @quantum__rt__array_remove_access(%"struct.QirArray"*)

; needed for the variadic array functions
declare void @llvm.va_start(i8*)
declare void @llvm.va_end(i8*)

;------------------------------------------------------------------------------
; tuples and callables
;
declare i8* @quantum__rt__tuple_create(i64)
declare void @quantum__rt__tuple_reference(i8*)
declare void @quantum__rt__tuple_unreference(i8*)
declare void @quantum__rt__tuple_add_access(i8*)
declare void @quantum__rt__tuple_remove_access(i8*)

declare void @quantum__rt__callable_reference(%"struct.QirCallable"*)
declare void @quantum__rt__callable_unreference(%"struct.QirCallable"*)
declare %"struct.QirCallable"* @quantum__rt__callable_create(void (i8*, i8*, i8*)**, i8*)
declare void @quantum__rt__callable_invoke(%"struct.QirCallable"*, i8*, i8*)
declare %"struct.QirCallable"* @quantum__rt__callable_copy(%"struct.QirCallable"*)
declare %"struct.QirCallable"* @quantum__rt__callable_make_adjoint(%"struct.QirCallable"*)
declare %"struct.QirCallable"* @quantum__rt__callable_make_controlled(%"struct.QirCallable"*)

;------------------------------------------------------------------------------
; strings
;
declare %"struct.QirString"* @quantum__rt__string_create(i8*)
declare void @quantum__rt__string_reference(%"struct.QirString"*)
declare void @quantum__rt__string_unreference(%"struct.QirString"*)
declare %"struct.QirString"* @quantum__rt__string_concatenate(%"struct.QirString"*, %"struct.QirString"*)
declare i1 @quantum__rt__string_equal(%"struct.QirString"*, %"struct.QirString"*)
declare %"struct.QirString"* @quantum__rt__int_to_string(i64)
declare %"struct.QirString"* @quantum__rt__double_to_string(double)
declare %"struct.QirString"* @quantum__rt__bool_to_string(i1)
declare %"struct.QirString"* @quantum__rt__result_to_string(%class.RESULT*)
declare %"struct.QirString"* @quantum__rt__pauli_to_string(i32)
declare %"struct.QirString"* @quantum__rt__qubit_to_string(%class.QUBIT*)
declare %"struct.QirString"* @quantum__rt__range_to_string(%"struct.QirRange"* dereferenceable(24) %range)



;=======================================================================================================================
; __quantum__rt__* bridge implementation
;=======================================================================================================================

;------------------------------------------------------------------------------
; classical bridge
;
define i8* @__quantum__rt__heap_alloc(i32 %size) {
  %mem = call i8* @quantum__rt__heap_alloc(i32 %size)
  ret i8* %mem
}

define void @__quantum__rt__heap_free(i8* %mem) {
  call void @quantum__rt__heap_free(i8* %mem)
  ret void
}

define void @__quantum__rt__fail(%String* %.str) {
  %str = bitcast %String* %.str to %"struct.QirString"*
  call void @quantum__rt__fail(%"struct.QirString"* %str)
  ret void
}


;------------------------------------------------------------------------------
; qubits bridge
;
; NYI:
;define %Qubit* @__quantum__rt__qubit_borrow()
;define void @__quantum__rt__qubit_return(%Qubit*)
;define %Array* @__quantum__rt__qubit_borrow_array(i64)
;define void @__quantum__rt__qubit_return_array(%Array*)
;
define %Qubit* @__quantum__rt__qubit_allocate() {
  %q = call %class.QUBIT* @quantum__rt__qubit_allocate()
  %.q = bitcast %class.QUBIT* %q to %Qubit*
  ret %Qubit* %.q
}

define void @__quantum__rt__qubit_release(%Qubit* %.q) {
  %q = bitcast %Qubit* %.q to %class.QUBIT*
  call void @quantum__rt__qubit_release(%class.QUBIT* %q)
  ret void
}

define %Array* @__quantum__rt__qubit_allocate_array(i64 %n) {
  %qa = call %"struct.QirArray"* @quantum__rt__qubit_allocate_array(i64 %n)
  %.qa = bitcast %"struct.QirArray"* %qa to %Array*
  ret %Array* %.qa
}

define void @__quantum__rt__qubit_release_array(%Array* %.qa) {
  %qa = bitcast %Array* %.qa to %"struct.QirArray"*
  call void @quantum__rt__qubit_release_array(%"struct.QirArray"* %qa)
  ret void
}


;------------------------------------------------------------------------------
; results bridge
;
define i1 @__quantum__rt__result_equal(%Result* %.r1, %Result* %.r2) {
  %r1 = bitcast %Result* %.r1 to %class.RESULT*
  %r2 = bitcast %Result* %.r2 to %class.RESULT*
  %c = call i1 @quantum__rt__result_equal(%class.RESULT* %r1, %class.RESULT* %r2)
  ret i1 %c
}

define void @__quantum__rt__result_reference(%Result* %.r) {
  %r = bitcast %Result* %.r to %class.RESULT*
  call void @quantum__rt__result_reference(%class.RESULT* %r)
  ret void
}

define void @__quantum__rt__result_unreference(%Result* %.r) {
  %r = bitcast %Result* %.r to %class.RESULT*
  call void @quantum__rt__result_unreference(%class.RESULT* %r)
  ret void
}


; -----------------------------------------------------------------------------
; arrays bridge
;
define %Array* @__quantum__rt__array_concatenate(%Array* %.head, %Array* %.tail) {
  %head = bitcast %Array* %.head to %"struct.QirArray"*
  %tail = bitcast %Array* %.tail to %"struct.QirArray"*
  %con = call %"struct.QirArray"* @quantum__rt__array_concatenate(%"struct.QirArray"* %head, %"struct.QirArray"* %tail)
  %.con = bitcast %"struct.QirArray"* %con to %Array*
  ret %Array* %.con
}

define %Array* @__quantum__rt__array_copy(%Array* %.ar, i2 %force) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  %ar_copy = call %"struct.QirArray"* @quantum__rt__array_copy(%"struct.QirArray"* %ar, i2 %force)
  %.ar_copy = bitcast %"struct.QirArray"* %ar_copy to %Array*
  ret %Array* %.ar_copy
}

; TODO: This bridge isn't cross-platform!
; it works on Windows but on Linux %args ends up not being a valid pointer.
declare void @DebugLogPtr(i8*)
define %Array* @__quantum__rt__array_create(i32 %item_size, i32 %dim_count, ...) {
  %args1 = alloca i8*, align 8
  %args2 = bitcast i8** %args1 to i8*
  call void @llvm.va_start(i8* %args2)
  %args = load i8*, i8** %args1, align 8
  ;call void @DebugLogPtr(i8* %args)
  %ar = call %"struct.QirArray"* @quantum__rt__array_create_nonvariadic(i32 %item_size, i32 %dim_count, i8* %args)
  call void @llvm.va_end(i8* %args2)
  %.ar = bitcast  %"struct.QirArray"* %ar to %Array*
  ret %Array* %.ar
}

define %Array* @__quantum__rt__array_create_1d(i32 %item_size, i64 %count) {
  %ar = call %"struct.QirArray"* @quantum__rt__array_create_1d(i32 %item_size, i64 %count)
  %.ar = bitcast  %"struct.QirArray"* %ar to %Array*
  ret %Array* %.ar
}

define i32 @__quantum__rt__array_get_dim(%Array* %.ar) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  %dim_count = call i32 @quantum__rt__array_get_dim(%"struct.QirArray"* %ar)
  ret i32 %dim_count
}

define i8* @__quantum__rt__array_get_element_ptr(%Array* %.ar, ...) {
  %args1 = alloca i8*, align 8
  %args2 = bitcast i8** %args1 to i8*
  call void @llvm.va_start(i8* %args2)
  %args = load i8*, i8** %args1, align 8
  %ptr = call i8* @quantum__rt__array_get_element_ptr_nonvariadic(%Array* %.ar, i8* %args)
  call void @llvm.va_end(i8* %args2)
  ret i8* %ptr
}

define i8* @__quantum__rt__array_get_element_ptr_1d(%Array* %.ar, i64 %i) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  %item =
    call i8* @quantum__rt__array_get_element_ptr_1d(%"struct.QirArray"* %ar, i64 %i)
  ret i8* %item
}

define i64 @__quantum__rt__array_get_length(%Array* %.ar, i32 %dim) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  %l = call i64 @quantum__rt__array_get_length(%"struct.QirArray"* %ar, i32 %dim)
  ret i64 %l
}

define i64 @__quantum__rt__array_get_size_1d(%Array* %.ar) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  %l = call i64 @quantum__rt__array_get_length(%"struct.QirArray"* %ar, i32 0)
  ret i64 %l
}

define %Array* @__quantum__rt__array_project(%Array* %.ar, i32 %dim, i64 %index) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  %project = call %"struct.QirArray"* @quantum__rt__array_project(%"struct.QirArray"* %ar, i32 %dim, i64 %index)
  %.project = bitcast  %"struct.QirArray"* %project to %Array*
  ret %Array* %.project
}

define void @__quantum__rt__array_reference(%Array* %.ar) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  call void @quantum__rt__array_reference(%"struct.QirArray"* %ar)
  ret void
}

define %Array* @__quantum__rt__array_slice(%Array* %.ar, i32 %dim, %Range %.range) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  %.prange = alloca %Range
  store %Range %.range, %Range* %.prange
  %range = bitcast %Range* %.prange to %"struct.QirRange"*
  %slice = call %"struct.QirArray"* @quantum__rt__array_slice(
      %"struct.QirArray"* %ar, i32 %dim, %"struct.QirRange"* dereferenceable(24) %range)
  %.slice = bitcast  %"struct.QirArray"* %slice to %Array*
  ret %Array* %.slice
}

define %Array* @__quantum__rt__array_slice_1d(%Array* %.ar, %Range %.range) {
  %.slice = call %Array* @__quantum__rt__array_slice(%Array* %.ar, i32 0, %Range %.range)
  ret %Array* %.slice
}

define void @__quantum__rt__array_unreference(%Array* %.ar) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  call void @quantum__rt__array_unreference(%"struct.QirArray"* %ar)
  ret void
}

define void @__quantum__rt__array_add_access(%Array* %.ar) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  call void @quantum__rt__array_add_access(%"struct.QirArray"* %ar)
  ret void
}

define void @__quantum__rt__array_remove_access(%Array* %.ar) {
  %ar = bitcast %Array* %.ar to %"struct.QirArray"*
  call void @quantum__rt__array_remove_access(%"struct.QirArray"* %ar)
  ret void
}

;------------------------------------------------------------------------------
; tuples bridge
;
define %Tuple* @__quantum__rt__tuple_create(i64 %size) {
  %th = call i8* @quantum__rt__tuple_create(i64 %size)
  %.th = bitcast i8* %th to %Tuple*
  ret %Tuple* %.th
}

define void @__quantum__rt__tuple_reference(%Tuple* %.th) {
  %th = bitcast %Tuple* %.th to i8*
  call void @quantum__rt__tuple_reference(i8* %th)
  ret void
}

define void @__quantum__rt__tuple_unreference(%Tuple* %.th) {
  %th = bitcast %Tuple* %.th to i8*
  call void @quantum__rt__tuple_unreference(i8* %th)
  ret void
}

define void @__quantum__rt__tuple_add_access(%Tuple* %.th) {
  %th = bitcast %Tuple* %.th to i8*
  call void @quantum__rt__tuple_add_access(i8* %th)
  ret void
}

define void @__quantum__rt__tuple_remove_access(%Tuple* %.th) {
  %th = bitcast %Tuple* %.th to i8*
  call void @quantum__rt__tuple_remove_access(i8* %th)
  ret void
}

;------------------------------------------------------------------------------
; callables bridge
;
define void @__quantum__rt__callable_reference(%Callable* %.clb) {
  %clb = bitcast %Callable* %.clb to %"struct.QirCallable"*
  call void @quantum__rt__callable_reference(%"struct.QirCallable"* %clb)
  ret void
}

define void @__quantum__rt__callable_unreference(%Callable* %.clb) {
  %clb = bitcast %Callable* %.clb to %"struct.QirCallable"*
  call void @quantum__rt__callable_unreference(%"struct.QirCallable"* %clb)
  ret void
}

define %Callable* @__quantum__rt__callable_create([4 x void (%Tuple*, %Tuple*, %Tuple*)*]* %.ft, %Tuple* %.capture) {
  %ft = bitcast [4 x void (%Tuple*, %Tuple*, %Tuple*)*]* %.ft to void (i8*, i8*, i8*)**
  %capture = bitcast %Tuple* %.capture to i8*
  %clb = call %"struct.QirCallable"* @quantum__rt__callable_create(void (i8*, i8*, i8*)** %ft, i8* %capture)
  %.clb = bitcast %"struct.QirCallable"* %clb to %Callable*
  ret %Callable* %.clb
}

define void @__quantum__rt__callable_invoke(%Callable* %.clb, %Tuple* %.args, %Tuple* %.res) {
  %clb = bitcast %Callable* %.clb to %"struct.QirCallable"*
  %args = bitcast %Tuple* %.args to i8*
  %res = bitcast %Tuple* %.res to i8*
  call void @quantum__rt__callable_invoke(%"struct.QirCallable"* %clb, i8* %args, i8* %res)
  ret void
}

define %Callable* @__quantum__rt__callable_copy(%Callable* %.clb) {
  %clb = bitcast %Callable* %.clb to %"struct.QirCallable"*
  %clb_copy = call %"struct.QirCallable"* @quantum__rt__callable_copy(%"struct.QirCallable"* %clb)
  %.clb_copy = bitcast %"struct.QirCallable"* %clb_copy to %Callable*
  ret %Callable* %.clb_copy
}

define %Callable* @__quantum__rt__callable_make_adjoint(%Callable* %.clb) {
  %clb = bitcast %Callable* %.clb to %"struct.QirCallable"*
  %clb_adj = call %"struct.QirCallable"* @quantum__rt__callable_make_adjoint(%"struct.QirCallable"* %clb)
  %.clb_adj = bitcast %"struct.QirCallable"* %clb_adj to %Callable*
  ret %Callable* %.clb_adj
}

define %Callable* @__quantum__rt__callable_make_controlled(%Callable* %.clb) {
  %clb = bitcast %Callable* %.clb to %"struct.QirCallable"*
  %clb_cnt = call %"struct.QirCallable"* @quantum__rt__callable_make_controlled(%"struct.QirCallable"* %clb)
  %.clb_cnt = bitcast %"struct.QirCallable"* %clb_cnt to %Callable*
  ret %Callable* %.clb_cnt
}

;------------------------------------------------------------------------------
; strings bridge
;
; NYI:
;define %String* @__quantum__rt__string_create(i32, [0 x i8])
;define %String* @__quantum__rt__pauli_to_string(%Pauli) ; need to check that the type is lowered correctly
;define %String* @__quantum__rt__bigint_to_string(%BigInt*)

; this is temporary (the spec calls for bounded buffers not null terminated)
define %String* @__quantum__rt__string_create(i32, i8* %null_terminated_buffer) {
  %str = call %"struct.QirString"* @quantum__rt__string_create(i8* %null_terminated_buffer)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}

define void @__quantum__rt__string_reference(%String* %.str) {
  %str = bitcast %String* %.str to %"struct.QirString"*
  call void @quantum__rt__string_reference(%"struct.QirString"* %str)
  ret void
}

define void @__quantum__rt__string_unreference(%String* %.str) {
  %str = bitcast %String* %.str to %"struct.QirString"*
  call void @quantum__rt__string_unreference(%"struct.QirString"* %str)
  ret void
}

define %String* @__quantum__rt__string_concatenate(%String* %.head, %String* %.tail) {
  %head = bitcast %String* %.head to %"struct.QirString"*
  %tail = bitcast %String* %.tail to %"struct.QirString"*
  %str = call %"struct.QirString"* @quantum__rt__string_concatenate(
    %"struct.QirString"* %head, %"struct.QirString"* %tail)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}

define i1 @__quantum__rt__string_equal(%String* %.str1, %String* %.str2) {
  %str1 = bitcast %String* %.str1 to %"struct.QirString"*
  %str2 = bitcast %String* %.str2 to %"struct.QirString"*
  %eq = call i1 @quantum__rt__string_equal(%"struct.QirString"* %str1, %"struct.QirString"* %str2)
  ret i1 %eq
}

define %String* @__quantum__rt__int_to_string(i64 %val) {
  %str = call %"struct.QirString"* @quantum__rt__int_to_string(i64 %val)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}

define %String* @__quantum__rt__double_to_string(double %val) {
  %str = call %"struct.QirString"* @quantum__rt__double_to_string(double %val)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}

define %String* @__quantum__rt__bool_to_string(i1 %val) {
  %str = call %"struct.QirString"* @quantum__rt__bool_to_string(i1 %val)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}

define %String* @__quantum__rt__result_to_string(%Result* %.r) {
  %r = bitcast %Result* %.r to %"class.RESULT"*
  %str = call %"struct.QirString"* @quantum__rt__result_to_string(%"class.RESULT"* %r)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}

define %String* @__quantum__rt__qubit_to_string(%Qubit* %.q) {
  %q = bitcast %Qubit* %.q to %"class.QUBIT"*
  %str = call %"struct.QirString"* @quantum__rt__qubit_to_string(%"class.QUBIT"* %q)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}

define %String* @__quantum__rt__range_to_string(%Range %.range) {
  %.prange = alloca %Range
  store %Range %.range, %Range* %.prange
  %range = bitcast %Range* %.prange to %"struct.QirRange"*
  %str = call %"struct.QirString"* @quantum__rt__range_to_string(%"struct.QirRange"* dereferenceable(24) %range)
  %.str = bitcast %"struct.QirString"* %str to %String*
  ret %String* %.str
}


;------------------------------------------------------------------------------
; bigints bridge
;
; NYI:
;define %BigInt* @__quantum__rt__bigint_create_i64(i64)
;define %BigInt* @__quantum__rt__bigint_create_array(i32, [0 x i8])
;define void @__quantum__rt__bigint_reference(%BigInt*)
;define void @__quantum__rt__bigint_unreference(%BigInt*)
;define %BigInt* @__quantum__rt__bigint_negate(%BigInt*)
;define %BigInt* @__quantum__rt__bigint_add(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_subtract(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_multiply(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_divide(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_modulus(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_power(%BigInt*, i32)
;define %BigInt* @__quantum__rt__bigint_bitand(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_bitor(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_bitxor(%BigInt*, %BigInt*)
;define %BigInt* @__quantum__rt__bigint_bitnot(%BigInt*)
;define %BigInt* @__quantum__rt__bigint_shiftleft(%BigInt*, i64)
;define %BigInt* @__quantum__rt__bigint_shiftright(%BigInt*, i64)
;define i1 @__quantum__rt__bigint_equal(%BigInt*, %BigInt*)
;define i1 @__quantum__rt__bigint_greater(%BigInt*, %BigInt*)
;define i1 @__quantum__rt__bigint_greater_eq(%BigInt*, %BigInt*)
;